"""
Technical Reports API Router for ITRC Evaluation System
Handles report generation, supervisor review, and download
"""

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
import os

from ..database import get_db
from ..models import TechnicalReport, Evaluation, User, UserRole, ReportStatus, ApplicationStatus
from ..schemas import TechnicalReportCreate, TechnicalReportResponse, TechnicalReportUpdate
from ..core.auth import get_current_user, get_current_active_user, require_role
from ..services.report_generator import TechnicalReportGenerator

router = APIRouter(tags=["reports"])

@router.get("/my-reports", response_model=List[TechnicalReportResponse])
async def get_my_reports(
    current_user: User = Depends(require_role([UserRole.EVALUATOR])),
    db: Session = Depends(get_db)
):
    """Get reports generated by current evaluator"""
    
    try:
        if not current_user or not current_user.is_active:
            raise HTTPException(status_code=401, detail="User not authenticated or inactive")
        print(f"Fetching reports for active user ID: {current_user.id} - Querying database...")
        reports = db.query(TechnicalReport).filter(TechnicalReport.generated_by == current_user.id).all()
        print(f"Reports fetched: {len(reports)} results")
        return reports  # Always return, even if empty
    except HTTPException as http_e:
        raise http_e
    except Exception as e:
        print(f"Critical error in get_my_reports for user {current_user.id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error: Please check logs")

@router.post("/generate/{evaluation_id}", response_model=TechnicalReportResponse)
async def generate_technical_report(
    evaluation_id: int,
    title: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Generate technical report for completed evaluation (Evaluator only)"""
    
    # Check if user is evaluator
    if current_user.role != UserRole.EVALUATOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only evaluators can generate reports"
        )
    
    # Get evaluation and verify ownership
    evaluation = db.query(Evaluation).filter(Evaluation.id == evaluation_id).first()
    if not evaluation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Evaluation not found"
        )
    
    if evaluation.evaluator_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only generate reports for your own evaluations"
        )
    
    # Check if evaluation is completed
    if evaluation.status != "completed":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Evaluation must be completed before generating report"
        )
    
    # Check if report already exists
    existing_report = db.query(TechnicalReport).filter(
        TechnicalReport.evaluation_id == evaluation_id
    ).first()
    if existing_report:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Report already exists for this evaluation: {existing_report.report_number}"
        )
    
    try:
        # Generate report
        generator = TechnicalReportGenerator(db)
        report = generator.generate_technical_report(
            evaluation_id=evaluation_id,
            generated_by_id=current_user.id,
            title=title
        )
        
        # Update application status
        evaluation.application.status = ApplicationStatus.REPORT_GENERATED
        evaluation.report_generated_at = datetime.now()
        db.commit()
        
        return report
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate report: {str(e)}"
        )

@router.get("/pending-review", response_model=List[TechnicalReportResponse])
async def get_pending_review_reports(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get reports pending supervisor review (Supervisor only)"""
    
    if current_user.role != UserRole.SUPERVISOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only supervisors can access pending review reports"
        )
    
    # Get evaluators supervised by this user
    supervised_evaluator_ids = [u.id for u in current_user.supervised_evaluators]
    
    # Get reports that are ready for review
    reports = db.query(TechnicalReport).filter(
        TechnicalReport.generated_by.in_(supervised_evaluator_ids),
        TechnicalReport.status.in_([ReportStatus.GENERATED, ReportStatus.SUPERVISOR_REVIEW])
    ).order_by(TechnicalReport.generated_at.desc()).all()
    
    return reports

@router.post("/submit-for-review/{report_id}")
async def submit_report_for_review(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Submit report for supervisor review (Evaluator only)"""
    
    if current_user.role != UserRole.EVALUATOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only evaluators can submit reports for review"
        )
    
    # Get report and verify ownership
    report = db.query(TechnicalReport).filter(TechnicalReport.id == report_id).first()
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    if report.generated_by != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only submit your own reports"
        )
    
    if report.status != ReportStatus.GENERATED:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Report is already in status: {report.status}"
        )
    
    # Update report status
    report.status = ReportStatus.SUPERVISOR_REVIEW
    report.submitted_for_review_at = datetime.now()
    
    # Update application status
    report.evaluation.application.status = ApplicationStatus.SUPERVISOR_REVIEW
    
    db.commit()
    
    return {"message": "Report submitted for supervisor review successfully"}

@router.post("/review/{report_id}")
async def review_report(
    report_id: int,
    review_data: TechnicalReportUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Review report as supervisor (Supervisor only)"""
    
    if current_user.role != UserRole.SUPERVISOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only supervisors can review reports"
        )
    
    # Get report
    report = db.query(TechnicalReport).filter(TechnicalReport.id == report_id).first()
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Verify supervisor has authority over this report's evaluator
    if report.generator.supervisor_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only review reports from your supervised evaluators"
        )
    
    if report.status != ReportStatus.SUPERVISOR_REVIEW:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Report is not in review status: {report.status}"
        )
    
    # Update report with review
    report.status = review_data.status
    report.supervisor_comments = review_data.supervisor_comments
    report.reviewed_by = current_user.id
    report.reviewed_at = datetime.now()
    
    if review_data.status == ReportStatus.APPROVED:
        report.approved_at = datetime.now()
        report.evaluation.application.status = ApplicationStatus.COMPLETED
    elif review_data.status == ReportStatus.NEEDS_REVISION:
        report.evaluation.application.status = ApplicationStatus.REPORT_GENERATED
    
    db.commit()
    
    return {"message": f"Report review completed with status: {review_data.status}"}

@router.get("/download/{report_id}")
async def download_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Download report file (Word document)"""
    
    # Get report
    report = db.query(TechnicalReport).filter(TechnicalReport.id == report_id).first()
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Check access permissions
    has_access = False
    
    if current_user.role == UserRole.EVALUATOR and report.generated_by == current_user.id:
        has_access = True
    elif current_user.role == UserRole.SUPERVISOR and report.generator.supervisor_id == current_user.id:
        has_access = True
    elif current_user.role in [UserRole.ADMIN, UserRole.GOVERNANCE]:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied to this report"
        )
    
    # Check if file exists
    if not report.word_file_path or not os.path.exists(report.word_file_path):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report file not found"
        )
    
    return FileResponse(
        path=report.word_file_path,
        filename=f"{report.report_number}.docx",
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    )

@router.get("/{report_id}", response_model=TechnicalReportResponse)
async def get_report_details(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get detailed report information"""
    
    # Get report
    report = db.query(TechnicalReport).filter(TechnicalReport.id == report_id).first()
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Check access permissions
    has_access = False
    
    if current_user.role == UserRole.EVALUATOR and report.generated_by == current_user.id:
        has_access = True
    elif current_user.role == UserRole.SUPERVISOR and report.generator.supervisor_id == current_user.id:
        has_access = True
    elif current_user.role in [UserRole.ADMIN, UserRole.GOVERNANCE]:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied to this report"
        )
    
    return report

@router.get("/", response_model=List[TechnicalReportResponse])
async def get_all_reports(
    status: Optional[ReportStatus] = None,
    evaluator_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all reports (Admin/Governance only)"""
    
    if current_user.role not in [UserRole.ADMIN, UserRole.GOVERNANCE]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    query = db.query(TechnicalReport)
    
    if status:
        query = query.filter(TechnicalReport.status == status)
    
    if evaluator_id:
        query = query.filter(TechnicalReport.generated_by == evaluator_id)
    
    reports = query.order_by(TechnicalReport.created_at.desc()).offset(skip).limit(limit).all()
    
    return reports

@router.delete("/{report_id}")
async def delete_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Delete report (Admin only)"""
    
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can delete reports"
        )
    
    # Get report
    report = db.query(TechnicalReport).filter(TechnicalReport.id == report_id).first()
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Delete file if exists
    if report.word_file_path and os.path.exists(report.word_file_path):
        os.remove(report.word_file_path)
    
    # Delete database record
    db.delete(report)
    db.commit()
    
    return {"message": "Report deleted successfully"} 